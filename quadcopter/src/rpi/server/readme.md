# I2C (Inter-integrated circuit)

http://www.i2c-bus.org/

https://learn.sparkfun.com/tutorials/i2c

The I2C bus allows multiple devices to be connected to your Raspberry Pi, each with a unique address. It is a 
protocol intended to allow multiple “slave” digital integrated circuits (“chips”) to communicate with one or 
more “master” chips. 

This tutorial compares I2C with SPI (Serial Peripheral Interface) and synchronous and asynchronous serial ports (like
UART). Some of these considerations are:
- One master connected to only one slave (serial ports and UART)
- Only one master but multiple slaves (SPI)
- Multiple pins needed to connect a master to a slave (SPI - 4 pins + additional chip select pin for each slave)
- No clock or keeping similar baud rates
- High data rate (10 MHz) with full-duplex i.e., simultaneous transmit and receive (SPI)

#### I2C advantages
- Two pins like asynchronous serial ports, but for multiple masters and slaves (I2C)
- Up to 1008 slaves with just two wires each
- Speeds between 100 kHz to 400 kHz
- Multiple masters communicate with all devices, though they take turns
- For every 8 bits of data, one bit of ACK/NACK should be sent
- Hardware for I2C is more complex than SPI but less complex that asynchronous serial like UART
- Software implementation for I2C is trivial
- Even faster modes added (up to 5 MHz)
- Variant of I2C = SMBus (System management bus) limits speeds from 10 kHz to 100 kHz

#### I2C at hardware level
- Two signals: SCL (clock signal) and SDA (data signal)
- Clock signal always generated by current bus master

# Configuring I2C on Raspberry Pi
https://learn.adafruit.com/adafruits-raspberry-pi-lesson-4-gpio-setup/configuring-i2c

To check which devices are connected to the Pi, we can use these tools.

```
sudo apt-get install -y python-smbus
sudo apt-get install -y i2c-tools
```
Add the following two lines in `/etc/modules`
```
i2c-bcm2708 
i2c-dev
```
Add the following two line in `/boot/config.txt`
```
dtparam=i2c1=on
dtparam=i2c_arm=on
```
After you reboot the system, you can check to see all connected devices by
```
sudo i2cdetect -y 1
```

# Configuring SPI on Raspberry Pi
Remove the following from `/etc/modprobe.d/raspi-blacklist.conf`
```
blacklist spi-bcm2708
```
After rebooting, test for two devices for the SPI bus using:
```
ls -l /dev/spidev*
```

# Configuring GPIO
The GPIO pins can be used as both digital outputs and digital inputs. As digital outputs, you can write 
programs that turn a particular pin HIGH or LOW. Setting it HIGH sets it to 3.3V setting it LOW sets it to 0V. 
To drive an LED from one of these pins, you need a 1kΩ resistor in series with the LED as the GPIO pins can 
only manage a small amount of power.

If you use a pin as a digital input, then you can connect switches and simple sensors to a pin and then be 
able to check whether it is open or closed (that is, activated or not).
```
sudo apt-get install python-rpi.gpio
```

https://learn.adafruit.com/adafruits-raspberry-pi-lesson-4-gpio-setup/the-gpio-connector

http://raspi.tv/2013/rpi-gpio-basics-4-setting-up-rpi-gpio-numbering-systems-and-inputs

https://learn.adafruit.com/basic-resistor-sensor-reading-on-raspberry-pi

This example shows how to read from digital input from a photocell that acts like a resistor. You connect this
it to a capacitor and use RC decay time to count how long it takes for the capacitor to charge up. By measuring 
the sensor as a resistor that is used to 'fill up' a capacitor, we can count how long RC decay time takes. 

A photocell changes the resistance based on how much light falls on it. This change in resistance changes the
RC decay time. Therefore, indirectly, this RC time can be used to detect how much light falls on it. 

#### Example: LED for unread Gmail messages
- Connect to the IMAP server using your username and password
- Loop this and check if you have unread messages in Gmail.
- When you have unread messages, set a GPIO output that is connected to an LED to HIGH

# PWM Servo board
Servo motor is a special type of DC motor with position control. A DC motor can be used for speed control but
it keeps rotating by changing the voltage applied. If we want position control, then we need to have current 
position and a desired position. This gives an error signal. The voltage applied is proportional to this error.
We could have a PID controller too. But the idea is for the servo motor to stop rotating when the desired angle 
is reached unlike a standard speed control DC motor.

```
git clone https://github.com/adafruit/Adafruit_Python_PCA9685.git
pip install adafruit-pca9685
```

https://projectgus.com/2009/07/servo-pulse-width-range-with-arduino/

https://learn.adafruit.com/16-channel-pwm-servo-driver?view=all

The servo motor setup and control has the following steps:
- Connect the servo motor to one of the channels in Adafruit PCA9685 board. It has power (red), ground (brown) and 
  PWM signal (orange) leads.
- Connect external power supply to the Adafruit PCA9685 board. This can be up to 6V.
- Connect the I2C connections from Adafruit PCA9685 board to Raspberry Pi: VCC (5V), Ground, SDA (data signal) and 
  SCL (clock signal)
- Servo motor can be accessed using an I2C address (like 0x40) and the channel.
- We send a PWM signal to the servo at a certain frequency. For motor MG996R, we need to use 50 Hz.
- The PWM duty cycle can be specified either in milliseconds (for the HIGH state) or using a 12 bit number.
- If using 12 bit number, the full cycle length is 4096 and you specify a value between 0 and 4096.
- Depending on the servo motor, there is also a servo_min and servo_max that are allowed (between 0 and 4096).
- These min and max values control how much angle the servo motor can turn, which is typically, at most 180 degrees.
- For motor MG996R, the servo_min and servo_max are 128 and 528 respectively. We should not send PWM value outside
  this range because it can damage the servo motor.
- For each new servo motor, you calibrate it and figure out the min and max values.

# CAN bus utils

http://www.instructables.com/id/CAN-Bus-Sniffing-and-Broadcasting-with-Arduino/

https://www.raspberrypi.org/forums/viewtopic.php?t=141052

https://www.cooking-hacks.com/documentation/tutorials/can-bus-module-shield-tutorial-for-arduino-raspberry-pi-intel-galileo/

http://www.cowfishstudios.com/blog/canned-pi-part1

http://copperhilltech.com/pican-2-can-interface-for-raspberry-pi/

http://chadgibbons.com/2016/01/08/can-bus-hacking-with-the-arduino-and-raspberry-pi/

```
sudo apt-get install can-utils
```

# Tensorflow on Raspberry Pi

https://www.linkedin.com/pulse/how-run-deep-neural-networks-weak-hardware-dmytro-prylipko/

The best performance is when you compile tensorFlow with 
```
OPTFLAGS="-Os -mfpu=neon-vfpv4 -funsafe-math-optimizations -ftree-vectorize" (tf-neon-vfpv4)
```

# Wifi IoT ESP8266

http://electronut.in/esp8266-desk-draw-protector/

https://learn.sparkfun.com/tutorials/esp8266-thing-hookup-guide/all
